=== Основи Git

Отже, що таке Git в двох словах?
Важливо розуміти цей розділ, тому що, якщо ви розумієте, що таке Git і основи того, як він працює, потім ефективне використання Git, ймовірно, буде набагато простішим.
Доки ви вивчаєте Git, спробуйте очистити свій розум від речей, які ви, можливо, знаєте про інші СКВ на кшталт CVS, Subversion чи Perforce; це допоможе вам уникнути деяких проблем при його використанні.
Хоч інтерфейс користувача Git та цих СКВ не дуже відрізняється, та Git зберігає і думає про інформацію геть інакше, і розуміння цих відмінностей допоможе вам уникнути плутанини при його використанні.(((Subversion)))(((Perforce)))

==== Знімки, а не відмінності

Основною відмінністю від інших систем (таких як Subversion та подібних їй) є те, як Git сприймає дані.
Концептуально, більшість СКВ зберігають інформацію як список файлових редагувань.
Ці інші системи (CVS, Subversion, Perforce, Bazaar тощо) розглядають інформацію як список файлів та змін кожного з них протягом деякого часу (це зазвичай називають __оснований на дельтах__ контроль версій).

.Збереження даних, як переліку змін від базової версії кожного файлу.
image::images/deltas.png[Storing data as changes to a base version of each file.]

Git не оброблює та не зберігає свої дані таким чином.
Замість цього, Git сприймає свої дані радше як низку знімків мініатюрної файлової системи.
У Git щоразу, як ви створюєте коміт, тобто зберігаєте стан вашого проекту, Git запам'ятовує як виглядають всі ваші файли в той момент і зберігає посилання на цей знімок.
Для ефективності, якщо файли не змінилися, Git не зберігає файли знову, просто робить посилання на попередній ідентичний файл, котрий вже зберігається. Git вважає свої дані більш як *потік знімків*. 

.Зберігання даних як знімків проекту за хронологією.
image::images/snapshots.png[Git зберігає дані як знімків проекту за хронологією.]

Це дуже важлива різниця між Git та майже всіма іншими СКВ.
З цієї причини в Git було заново переосмислено майже кожен аспект контролю версій, які інші системи просто копіювали з попереднього покоління.
Це зробило Git більш схожим на мініатюрну файлову систему з деякими неймовірно потужними вбудованими інструментами на додаток, а не просто СКВ.
Ми познайомимось з деякими перевагами, які ви отримаєте при сприйнятті інформації подібним чином, у <<ch03-git-branching#ch03-git-branching>>, де йдеться про гілки.

==== Майже кожна операція локальна

Більшість операцій у Git потребують лише локальних файлів та ресурсів для здійснення операцій -- немає необхідності в інформації з інших комп’ютерів вашої мережі.
Якщо ви звикли до ЦСКВ, де більшість операцій обтяжені такими мережевими запитами, то цей аспект може привести вас до думки, що боги швидкості наділили Git неземною силою.
Через те, що повна історія проекту знаходиться на вашому локальному диску, більшість операцій здійснюються майже миттєво.

Наприклад, для перегляду історії проекту, Git не має потреби брати її з серверу, він просто зчитує її прямо з локальної бази даних.
Це означає, що ви отримуєте історію проекту не встигнувши кліпнути оком.
Якщо ви бажаєте переглянути відмінності між поточною версією файлу та його редакцією місячної давності, Git знайде копію збережену місяць тому і проведе локальне обчислення різниці замість того, щоб звертатись за цим до віддаленого серверу чи спочатку робити запит на отримання старішої версії файлу.

Також це означає, що за відсутності мережевого з’єднання ви не будете мати особливих обмежень.
Перебуваючи в літаку чи потязі можна цілком комфортно створювати коміти (у своїй _локальній_ копії, не забули?), доки не відновите з’єднання з мережею для їх відвантаження.
Якщо ви прийшли додому та не можете змусити належним чином працювати свій VPN-клієнт, усе одно можна продовжувати роботу.
У багатьох інших системах подібні дії або неможливі, або пов’язані з безліччю труднощів.
Наприклад, у Perforce, без з’єднання з мережею вам не вдасться зробити багато; у Subversion та CVS ви можете редагувати файли, але не можете створювати коміти з внесених змін (оскільки немає зв’язку з базою даних).
На перший погляд такі речі здаються незначними, але ви будете вражені наскільки велике значення вони можуть мати.

==== Git цілісний

Будь-що в Git, перед збереженням, отримує контрольну суму, за якою потім і можна на нього посилатися.
Таким чином, неможливо змінити файл чи директорію так, щоб Git про це не дізнався.
Цей функціонал вбудовано в систему на найнижчих рівнях і є невід’ємною частиною її філософії.
Ви не можете втратити інформацію при передачі чи отримати пошкоджений файл без відома Git.

Механізм, який використовується для цього контролю, називається хеш SHA-1.(((SHA-1)))
Він являє собою 40-символьну послідовність цифр та перших літер латинського алфавіту (a-f) і вираховується на основі вмісту файлу чи структури директорії в Git.
SHA-1 хеш виглядає це приблизно так:

[source]
----
24b9da6552252987aa493b52f8696cd6d3b00373
----

При роботі з Git ви повсюди зустрічатимете такі хеші, адже Git постійно їх використовує.
Фактично, Git зберігає все не за назвою файлу, а саме за значенням хешу його змісту.

=== Git, зазвичай, тільки додає дані

Коли ви виконуєте певні дії в Git, при цьому, майже завжди відбувається виключно _додавання_ інформації до бази даних Git.
Складно змусити систему зробити щось невиправне чи повністю видалити дані будь-яким чином.
Як і в будь-якій СКВ, ви можете втратити чи зіпсувати лише не збережені в коміті зміни, але це майже неможливо, коли вже збережено знімок, особливо, якщо ви регулярно надсилаєте свою базу до іншого сховища.

Це робить використання Git приємним, оскільки ми точно можемо експериментувати без загрози щось зіпсувати.
Про те, як Git зберігає інформацію та як можна відновити втрачені дані, що нібито загублені, детальніше розповідається у <<ch02-git-basics-chapter#_undoing>>.

=== Три стани

Тепер будьте уважні -- це найважливіша річ, яку потрібно запам’ятати, якщо ви хочете щоб подальше вивчення Git пройшло гладко.
Git має три основних стани, в яких можуть перебувати ваші файли: __збережений у коміті__ (commited), _змінений_ (modified) та _індексований_ (staged):

* Збережений у коміті означає, що дані безпечно збережено в локальній базі даних.
* Змінений означає, що у файл внесено редагування, які ще не збережено в базі даних.
* Індексований стан виникає тоді, коли ви позначаєте змінений файл у поточній версії, щоб ці зміни ввійшли до наступного знімку коміту.

З цього випливають три основні частини проекту під управлінням Git: директорія Git, робоче дерево та індекс.

.Робоча директорія, індекс та директорія Git.
image::images/areas.png["Робоче дерево, індекс та директорія Git."]

У директорії Git система зберігає метадані та базу даних об’єктів вашого проекту.
Це найважливіша частина Git, саме вона копіюється при _клонуванні_ сховища з іншого комп’ютеру.

Робоче дерево -- це одна окрема версія проекту, взята зі сховища.
Ці файли видобуваються з бази даних у теці Git та розміщуються на диску для подальшого використання та редагування.

Індекс -- це файл, що зазвичай знаходиться в директорії Git і містить інформацію про те, що буде збережено у наступному коміті.
Також цей файл називають ``областю додавання'' (staging area), проте ми переважно будемо користуватись технічним терміном Git ``індекс''.

Найпростіший процес взаємодії з Git виглядає приблизно так:

1. Ви редагуєте файли у своїй робочій директорії.
2. Вибірково надсилаєте до індексу лише ті зміни, що їх ви бажаєте зберегти в наступному коміті, і _лише_ ці зміни буде збережено в індексі.
3. Створюєте коміт: знімок з індексу остаточно зберігається в директорії Git.

У випадку, якщо окрема версія файлу вже є в директорії Git, цей файл вважається збереженим у коміті.
Якщо він зазнав змін і перебуває в індексі, то він індексований.
Якщо ж його стан відрізняється від того, який був у коміті, і файл не знаходиться в індексі, то він називається зміненим.
У <<ch02-git-basics-chapter#ch02-git-basics-chapter>> ви дізнаєтесь більше про ці стани, а також про те, як використовувати їхні переваги або взагалі пропускати етап індексу.
