=== Супроводжування проекту

(((maintaining a project)))
Окрім знань щодо того, як ефективно зробити внесок до проекту, вам можливо знадобиться вміння супроводжувати його.
Це може включати прийняття та застосування латок, які були згенеровані `format-patch` та надіслані вам поштою, або інтегрувати зміни з віддалених гілок зі сховища, яке ви додали були додали як віддалене для вашого проекту.
Чи ви супроводжуєте канонічний репозиторій, чи бажаєте допомогти перевіряти чи схвалювати латки, вам треба знати, як приймати роботу в спосіб, який є найзрозумілішим для інших учасників та щоб ви були в змозі підтримувати його у майбутньому.

==== Робота з тематичними гілками

(((branches, topic)))
Коли ви збираєтесь інтегрувати нову роботу, зазвичай слушно випробувати її в тематичній гілці – тимчасова гілка, спеціально створена для перевірки нової роботи.
У такому разі буде легко окремо налаштовувати латку та облишити її, якщо вона не працює, доки не зʼявиться час щоб повернутися до неї.
Якщо ви виберете просте імʼя для гілки, яке засноване на тематиці роботи, яку ви збираєтесь випробувати, наприклад `ruby_client` чи щось не менш змістовне, то легко зможете пригадати його, якщо ви покинули її на деякий час та вирішили повернутись до неї пізніше.
Супроводжувач проекту Git переважно також розподіляють ці гілки по просторам імен – на кшталт `sc/ruby_client`, де `sc` є скороченням від імені автора роботи.
Як ви памʼятаєте, ви можете відгалузити гілку від вашого master таким чином:

[source,console]
-----
$ git branch sc/ruby_client master
-----

Або, якщо ви бажаєте відразу до неї переключитися, то можете використати `checkout -b`:

[source,console]
-----
$ git checkout -b sc/ruby_client master
-----

Тепер ви готові додати внесок до цієї театичної гілки та визначити, чи варто це зливати до довготриваліших гілок.

[[_patches_from_email]]
==== Застосування латок отриманих поштою

(((email, applying patches from)))
Якщо ви отримали латку через електронну пошту та потрібно її інтегрувати до проекту, то треба застосувати латку в тематичній гілці, щоб перевірити її.
Є два методи застосувати надіслану латку: за допомогою `git apply` або `git am`.

===== Застосування латки за допомогою apply

(((git commands, apply)))
Якщо ви отримали латко від когось, хто згенерував її командою `git diff` або командою Unix `diff` (не рекомендовано; дивіться наступну підсекцію), то її можна застосувати за допомогою команди `git apply`.
Припускаючи, що латку збережено в `/tmp/patch-ruby-client.patch`, її можна застосувати наступним чином:

[source,console]
-----
$ git apply /tmp/patch-ruby-client.patch
-----

Це змінює файли у вашій робочій директорії.
Це майже те саме, що виконати команду `patch -p1`, щоб застосувати латку, хоча він є більш пароноїдальним та приймає менше невизначених збігів, ніж patch.
Він також опрацьовує додавання, вилучення та перейменування файлів, якщо вони описані в форматі `git diff`, чого `patch` не зробить.
Нарешті, `git apply` працює за принципом ``застосувати все або скасувати все'': буде застосовано все або нічого, у той час як `patch` може частково застосувати латки, залишивши робочу директорію в дивному стані.
Загалом `git apply` набагато консервативніший, ніж `patch`.
Він не створить для вас коміт – після виконання, вам доведеться індексувати та зберегти нові зміни вручну.

Ви також можете використати git apply щоб побачити, чи латка може бути застосована чисто перед тим, як власно намагатись справді застосувати її – ви можете виконати `git apply --check` з латкою:

[source,console]
-----
$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
-----

Якщо вивід порожній, то латка має застосуватися чисто.
Ця команда також виходить з не нульовим статусом, якщо перевірка зазнає невдачі, отже її можна використовувати в скриптах, якщо забажаєте.

[[_git_am]]
===== Застосування латки за допомогою `am`

(((git commands, am)))
Якщо автор змін є користувачем Git та був достатньо добрим, щоб використати команду `format-patch` задля генерації латки, то ваше завдання буде легшим, адже латка містить інформацію про автора та повідомлення коміту.
Якщо можете, заохочуйте ваших розробників використовувати `format-patch` замість `diff` для генерації латок для вас.
Ви маєте використовувати `git apply` лише для застарілих латок та тому подібних речей.

Щоб застосувати латку, що її згенерувала `format-patch`, скористуйтесь `git am`.
Технічно, `git am` створено щоб прочитати файл mbox, що є простим, текстовим форматом для збереження одного чи більше поштових повідомлень в одному текстовому файлі.
Виглядає він приблизно так:

[source,console]
-----
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20
-----

Це початок виводу команди format-patch, яку ви бачили у попередній секції.
Це також відповідаю поштовому формату mbox.
Якщо хтось правильно надіслав вам латку, використовуючи git send-email, та ви завантажили її у форматі mbox, то ви можете вказати git цей mbox файл, та він розпочне застосовувати всі латки, які зустріне.
Якщо ви користуєтесь поштовим клієнтом, який може зберегти декілька листів у mbox форматі, то можете зберегти всю послідовність латок до одного файлу, а потім використати git am щоб застосувати їх усіх по одному.

Втім, якщо хтось відвантажив файл латки, який згенерував `format-patch`, до системи завдань (ticketing system) чи чогось подібтого, то файл можна зберегти локально та потім передати його з вашого диску до `git am` для застосування:

[source,console]
-----
$ git am 0001-limit-log-function.patch
Applying: add limit to log function
-----

Як ви можете бачити, команда чисто застосувала та автоматично створила новий коміт для вас.
Інформація про автора взята зі заголовків листа `From` та `Date`, а повідомлення коміту взято зі `Subject` та тіла (перед латкою) листа.
Наприклад, якби латка застосовувалась з наведеного вище прикладу mbox, згенерований коміт виглядав би приблизно так:

-----
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20
-----

Інформація `Commit` містить людину, яка застосувала латку та час застосування.
Інформація `Author` -- особу, яка оригінально створила латку та коли це було зроблено.

Проте можливо, що латка не застосовується чисто.
Можливо, ваша головна гілка відхилилася надто далеко від гілки, на якій базувалася латка, або латка залежить від іншої латки, яку ви досі не застосували.
У цьому випадку, процес `git am` завершиться невдачею, та спитає вас, що робити:

[source,console]
-----
$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
-----

Ця команда додає позначки конфліктів до всіх файлів, з якими в неї є проблеми -- так само, як при конфліктах злиття чи перебазування.
Ви розв’язуєте ці проблеми так само – редагуєте файл, щоб розв’язати конфлікт, індексуєте оновлений файл, а потім  виконуєте `git am --resolved`, щоб продовжити з наступною латкою:

[source,console]
-----
$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
-----

Якщо ви бажаєте, щоб Git спробував поводитись трохи розумніше при розв’язуванні конфлікту, то можете передати опцію `-3`, з якою Git спробує три-точкове злиття (three-way merge).
Ця опція типово не ввімкнена, адже вона не працює, якщо коміту, на якому базується латка, немає у вашому репозиторії.
Якщо ви маєте цей коміт – якщо латка базувалася на публічному коміті – то зазвичай опція `-3` набагато кмітливіше застосовує конфліктну латку.

[source,console]
-----
$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
-----

У даному випадку, ця латка вже була застосована.
Без опції `-3` це схоже на конфлікт.

Якщо ви застосовуєте декілька латок з mbox, ви також можете виконати команду `am` в інтерактивному режимі, який зупиняється після кожної знайденої латки та питає, чи варто її застосовувати:

[source,console]
-----
$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
-----

Це зручно, якщо у вас збережено чисельні латки, адже ви можете спочатку переглянути латку, якщо не пам’ятаєте про що вона, або не застосовувати вже застосовані латки.

Коли всі латки для вашої гілки застосовані та збережені в комітах гілки, ви можете вибрати, як інтегрувати їх до довгостроковіших гілок.

[[_checking_out_remotes]]
==== Отримання віддалених гілок

(((branches, remote)))
Якщо внесок прийшов від користувача Git, який налаштував свій власний репозиторій, надіслав до нього декілька змін, та відправив вам URL цього сховища, а також ім’я віддаленої гілки, яка містить зміни, то можете додати його як віддалене сховище та зробити локальне злиття.

Наприклад, якщо Джесіка надсилає вам листа, в якому розповідає про чудовий новий функціонал у гілці `ruby-client` її сховища, то ви можете подивитись на них, якщо додасте віддалене сховище та отримаєте цю гілку локально:

[source,console]
-----
$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
-----

Якщо пізніше вона знову надішле вам листа з іншою гілкою з ще однією чудовою функцією, то ви зможете отримати зміни, адже у вас вже є її віддалене сховище.

Це найкорисніше, якщо ви працюєте з кимось постійно.
Якщо хтось має лише єдину латку для внеску подеколи, то на прийняття її листом може піти менше часу, ніж вимагати від когось мати власний сервер та постійно додавати та вилучати віддалені сховища задля отримання нових латок.
Також навряд чи вам сподобається мати сотні віддалених репозиторіїв, у кожен з яких було додано лише одну чи дві латки.
Втім, скрипти та сервіси розгортання (hosted services)) можуть полегшити це – переважно все залежить від того, як працюєте ви, та як працюють автори внесків.

Інша перевага цього підходу в тому, що ви також отримуєте історію комітів.
Хоча у вас можуть бути справжні проблеми злиття, ви будете знати на чому з вашої історії вони основані; належне три-точкове злиття є типовим -- немає необхідності додавати `-3` та сподіватись, що латку було згенеровано на базі публічного коміту, до якого ви маєте доступ.

Якщо ви не співпрацюєте з людиною постійно, проте все одно бажаєте отримати зміни в такий спосіб, то можете надати URL віддаленого сховища команді `git pull`.
Це робить одноразове отримання змін та не зберігає URL як посилання на віддалений репозиторій:

[source,console]
-----
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -> FETCH_HEAD
Merge made by recursive.
-----

[[_what_is_introduced]]
==== Як дізнатися, що додано

(((branches, diffing)))
Тепер у вас є тематична гілка, яка містить внесену працю.
Тепер ви можете визначити, що ви бажаєте з нею робити.
Ця секція розглядає наново декілька команд, щоб ви могли бачити, як їх можна використовувати для перегляду саме того, що буде додано в разі зливання до головної гілки.

Часто допомагає переглянути всі коміти, які є в поточній гілці, проте яких немає в гілці master.
Коміти з головної гілки можна виключити за допомогою опції `--not` перед ім’ям гілки.
Це робить те саме, що й формат `master..contrib`, що ми його використовували раніше.
Наприклад, якщо вам надіслано дві латки та ви створили гілку під назвою `contrib` та застосували їх до неї, то можете виконати:

[source,console]
-----
$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon <schacon@gmail.com>
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better
-----

Щоб побачити, які зміни привносить кожен коміт, згадайте опцію `-p` команди `git log`, яка додає привнесену різницю після кожного коміту.

Щоб побачити повну різницю того, що буде в разі зливання тематичної гілки до іншої, можливо вам доведеться вдатися до хитрощів, щоб отримати правильний результат.
Вам може спасти на думку виконати наступне:

[source,console]
-----
$ git diff master
-----

Ця команда видає вам різницю, проте вона може бути оманливою.
Якщо гілка `master` пішла вперед після створення тематичної гілки на її базі, то ви отримаєте назверх дивний результат.
Так сталося через те, що Git напряму порівнює відбитки останнього коміту поточної тематичної гілки та відбиток останнього коміту в гілці `master`.
Наприклад, якщо ви додали рядок у файлі в гілці `master`, пряме порівняння цих відбитків виглядатиме ніби тематична гілка збирається вилучити цей рядок.

Якщо `master` є прямим предком тематичної гілки, то це не буде проблемою; проте якщо ці дві історії розійшлися, різниця виглядатиме ніби ви додаєте все нове зі своєї тематичної гілки та видаляєте все, що зʼявилося лише в гілці `master`.

Що вам дійсно потрібно побачити -- це зміни, додані до тематичної гілки – праця, яку ви запровадите, якщо зіллєте цю гілку до master.
Це можна зробити, якщо порівняти останній коміт тематичної гілки з першим спільним предком, який вона має з гілкою master.

Технічно, ви можете зробити це явно зʼясувавши спільного предка та виконавши diff з ним:

[source,console]
-----
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
-----

Втім, це незручно, отже Git надає ще одне скорочення для того самого: синтаксис потрійної крапки.
У контексті команди `diff`, ви можете поставити три крапки після іншої гілки, щоб побачити різницю між останнім комітом поточної гілки та її спільного предка з іншою гілкою:

[source,console]
-----
$ git diff master...contrib
-----

Ця команда показує лише зроблене у поточній тематичній гілці після спільного з master предка.
Цей синтаксис дійсно варто запамʼятати.

==== Інтеграція внеску

(((integrating work)))
Коли вся робота в тематичній гілці готова для інтеграції до головнішої гілки, постає питання: як це зробити.
Ба більше: який загальний процес роботи ви бажаєте використати для супроводження свого проекту?
У вас є чимало варіантів, отже ми розглянемо декілька з них.

===== Процеси роботи зливання

(((workflows, merging)))
Одним з простих процесів роботи є зливання праці до гілки `master`.
У цьому сценарії, гілка `master` містить зазвичай стабільний код.
Коли зʼявляється робота в тематичній гілці, яку ви виконали чи хтось інший запропонував та ви перевірили, ви зливаєте її до гілки master, вилучаєте тематичну гілку, та продовжуєте цей процес.
Якщо в нас є репозиторій з роботою в двох гілках під назвами `ruby_client` та `php_client`, що мають вигляд <<merwf_a>> та ми зіллємо спочатку `ruby_client`, а потім `php_client`, то наша історія в результати виглядатиме як <<merwf_b>>.

[[merwf_a]]
.Історія з декількома тематичними гілками.
image::images/merging-workflows-1.png[Історія з декількома тематичними гілками.]

[[merwf_b]]
.Після злиття тематичної гілки.
image::images/merging-workflows-2.png[Після злиття тематичної гілки.]

Це, напевно, найпростіший процес роботи, проте він може бути проблемним, якщо треба працювати з більшими або стабільнішими проектами, в яких ви бажаєте бути дійсно обережними з новими змінами.

Якщо у вас важливіший проект, то можна скористатися двофазним циклом зливання.
У цьому сценарії, у вас є дві довгострокові гілки: `master` та `develop`. Ви домовляєтесь оновлювати `master` лише коли зʼявляється дуже стабільна версія, а весь новий код інтегрується до гілки `develop`.
Ви регулярно надсилаєте зміни до обох цих гілок до публічного сховища.
Щоразу, коли виникає готова до злиття тематична гілка (<<merwf_c>>), ви зливаєте її до `devlop` (<<merwf_d>>); потім, коли ви створите теґ перевіреної версії, то перемотує вперед `master` до останнього коміту тепер стабільного `develop` (<<merwf_e>>).

[[merwf_c]]
.Перед злиттям тематичної гілки.
image::images/merging-workflows-3.png[Before a topic branch merge.]

[[merwf_d]]
.Після злиття тематичної гілки.
image::images/merging-workflows-4.png[After a topic branch merge.]

[[merwf_e]]
.Після випуску проекту.
image::images/merging-workflows-5.png[Після випуску проекту.]

Таким чином, коли хтось створює клон сховища вашого проекту, вони можуть або отримати master, щоб зібрати останню стабільну версію та легко оновлюватись, або можуть отримати develop, в якому все найновіше.
Ви також можете продовжити цю концепцію: додати гілку інтеграції, в якій вся робота зливається разом.
Потім, коли код у цій гілці стає стабільним та проходить тести, ви зливаєте її до гілки develop; а вже коли вона дійсно довела свою стабільність, ви перемотуєте вперед гілку master.

===== Large-Merging Workflows
===== Процеси роботи великих зливань

(((workflows, "merging (large)")))
Проект Git має чотири довгострокових гілки: `master`, `next` та `pu` (proposed updates -- пропоновані оновлення) для нової роботи, та `main` для виправлень старших версій.
Коли учасники впроваджують щось нове, воно накопичується в тематичних гілках у сховищі супроводжувача -- схоже на вищеописані методи (дивіться <<merwf_f>>).
Потім тематичні гілки перевіряють, щоб визначити, чи вони є безпечними та готовими для використання, чи треба ще над ними працювати.
Якщо вони безпечні, їх зливають до `next`, і цю гілку надсилають до сервера, аби всі могли спробувати злити тематичні гілки разом.

[[merwf_f]]
.Керування складною послідовністю паралельних доданих тематичних гілок.
image::images/large-merges-1.png[Керування складною послідовністю паралельних доданих тематичних гілок.]

Якщо теми досі потребують доопрацювання, їх натомість зливають до `pu`.
Коли визначено, що вони цілковито стабільні, їх зливають вдруге -- до `master`, а потім збирається з тем, які були в `next`, проте покищо не потрапили до `master`.
Це означає, що `master` майже завжди рухається вперед, `next` іноді перебазовують, а `pu` перебазовують навіть частіше:

.Зливання доданих тематичних гілок до довготривалих інтеграційних гілок.
image::images/large-merges-2.png[Зливання доданих тематичних гілок до довготривалих інтеграційних гілок.]

Коли тематичну гілку нарешті зливають до `master`, її вилучать з репозиторію.
Проект Git також містить гілку `main`, яка відгалужена від останнього видання (release), щоб постачати латки до цієї версії, якщо необхідно супроводження цього видання.
Отже, коли ви робите клон сховища Git, у вас є чотири гілки, на які ви можете переключитися, щоб випробувати проект на різних ступінях розробки, в залежності від того, наскільки новітня версія вам потрібна, чи яким чином ви бажаєте зробити внесок; та супроводжувач має структурований процес роботи, щоб йому було зручно оцінити нових учасників.

[[_rebase_cherry_pick]]
===== Процеси роботи з перебазуванням та висмикуванням

(((workflows, rebasing and cherry-picking)))
Інші супроводжувачі надають перевагу перебазуванню та висмикуванню нової роботи поверху їхньої гілки master, замість зливання до неї, задля якомога лінійнішої історії.
Коли у вас є робота в тематичній гілки, та ви вирішили, що бажаєте її інтегрувати, ви переходите до цієї гілки та виконуєте команду rebase, щоб перебудувати зміни поверху вашої поточної гілки master (або `develop` тощо).
Якщо все вийшло добре, ви можете перемотати вперед свою гілку `master`, та отримаєте лінійну історію проекту.

(((git commands, cherry-pick)))
Інший спосіб перемістити впроваджену роботу з однієї гілки до іншої -- висмикнути її.
Висмикування в Git -- це ніби перебазування для єдиного коміту.
Воно бере латку, яку запровадив коміт, та намагається застосувати його на поточній гілці.
Це корисно, якщо у вас є декілька комітів у тематичній гілці, та ви бажаєте інтегрувати лише один з них, або якщо у вас лише один коміт у тематичній гілці, та вам легше висмикнути його, ніж виконувати перебазування.
Наприклад, припустимо, що у вас є ось такий проект:

.Приклад історії перед висмикуванням.
image::images/rebasing-1.png[Приклад історії перед висмикуванням.]

Якщо ви бажаєте додати коміт `e43a6` до гілки master, ви можете виконати

[source,console]
-----
$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
-----

Це додає ті ж зміни, що були впроваджені в `e43a6`, проте ви отримуєте нове значення SHA-1 коміту, адже дата застосування інша.
Тепер історія виглядає так:

.Історія після висмикування коміту з тематичної гілки.
image::images/rebasing-2.png[Історія після висмикування коміту з тематичної гілки.]

Тепер ви можете вилучити тематичну гілку та викинути коміти, які ви не бажали додавати.

===== Rerere

(((git commands, rerere)))(((rerere)))
Якщо ви робите багато зливань та перебазувань, або супроводжуєте довготривалу тематичну гілку, Git має функціонал під назвою ``rerere'', який може стати в пригоді.

Rerere означає ``використовуй записані розвʼязання'' (reuse recorded resolution) -- це метод скоротити ручні розвʼязання конфліктів.
Коли rerere ввімкнено, Git зберігає набір відбитків станів до та після успішних зливань, та якщо бачить конфлікт, який виглядає саме так, як якийсь вже розвʼязаний, він просто використає попереднє розвʼязання, і не буде вас ним турбувати.

У цієї функції є дві частини: налаштування та команда.
Налаштування називається `rerere.enabled`, та є достатньо корисним, щоб додати його до вашої глобальної конфігурації:

[source,console]
----
$ git config --global rerere.enabled true
----

Тепер, щоразу як ви робити зливання, яке розвʼязує конфлікти, розвʼязання буде збережено в памʼяті на випадок, якщо воно знадобиться в майбутньому.

Якщо потрібно, ви можете взаємодіяти з памʼяттю rerere за допомогою команди `git rerere`.
Якщо викликати окремо, Git перевіряє базу даних розвʼязань та намагається знайти збіг з будь-яким поточним конфліктом злиття та розвʼязує їх (хоча це здійснюється автоматично, якщо `rerere.enabled` встановлено в `true`).

Також існують підкоманди, для перегляду того, що буде записано, для стирання окремого розвʼязання з памʼяті, та щоб очистити всю памʼять. Ми розглянемо rerere докладніше в <<_rerere>>.

[[_tagging_releases]]
==== Теґування ваших видань (release)

(((tags)))(((tags, signing)))
Коли ви вирішили випустити видання, ви, вірогідно, забажаєте створити теґ, щоб мати можливість відтворити його після того.
Як ви можете створити новий теґ, розказано в <<_git_basics_chapter>>.
Якщо ви, як супроводжувач, вирішите підписати теґ, процес може виглядати приблизно так:

[source,console]
-----
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
-----

Якщо ви підписуєте свої теґи, то може виникнути проблема розповсюдження публічних ключів PGP, який використовується для підписання теґів.
Супроводжувач проекту Git впорався з цією проблемою: включив публічний ключ як блоб в сховищі, та додав теґ, який вказує прямо на його вміст.
Щоб це зробити, ви можете зрозуміти, який ключ вам потрібен за допомогою `gpg --list-keys`:

[source,console]
-----
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon <schacon@gmail.com>
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
-----

Потім, ви можете напряму імпортувати ключ до бази даних Git, якщо експортуєте його та пропустити через команду `git hash-object`, яка записує новий блоб з його вмістом до Git та видає SHA-1 цього блобу:

[source,console]
-----
$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

Тепер вміст вашого ключу є в Git, ви можете створити теґ, який вказує прямо на нього, якщо вкажете нове значення SHA-1, яке надала нам команда `hash-object`.

[source,console]
-----
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
-----

Якщо виконати `git push --tags`, то теґ `maintainer-pgp-pub` стане доступним всім.
Якщо хтось забажає перевірити теґ, то він зможе напряму імпортувати ваш PGP ключ. Для цього йому треба дістати блоб напряму з бази даних та імпортувати його до GPG:

[source,console]
-----
$ git show maintainer-pgp-pub | gpg --import
-----

Він зможе використати ключ щоб перевірити всі підписані теґи.
Також, якщо ви включите інструкції в повідомлення теґу, то виконання `git show <теґ>` дозволить вам надати користувачу більш детальні інструкції щодо перевірки теґу.

[[_build_number]]
==== Generating a Build Number

(((build numbers)))(((git commands, describe)))
Because Git doesn't have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you're describing:

[source,console]
-----
$ git describe master
v1.6.2-rc1-20-g8c5b85c
-----

This way, you can export a snapshot or build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this.
If you're describing a commit that you have directly tagged, it gives you the tag name.

The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you're using `git describe`, to ensure the commit is named properly when described.
You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.

[[_preparing_release]]
==== Preparing a Release

(((releasing)))(((git commands, archive)))
Now you want to release a build.
One of the things you'll want to do is create an archive of the latest snapshot of your code for those poor souls who don't use Git.
The command to do this is `git archive`:

[source,console]
-----
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
-----

If someone opens that tarball, they get the latest snapshot of your project under a project directory.
You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:

[source,console]
-----
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
-----

You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.

[[_the_shortlog]]
==== The Shortlog

(((git commands, shortlog)))
It's time to e-mail your mailing list of people who want to know what's happening in your project.
A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the `git shortlog` command.
It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:

[source,console]
-----
$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2
-----

You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.
